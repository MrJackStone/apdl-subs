! SCANPATH, item, comp, aggOpt, csecPrefix, planeDefiningNodes, overridingPathLabel
! SCANPATH, arg1, arg2,   arg3,       arg4,               arg5,                arg6

! Description:
! Scans the current active path calculating, at each path division point, the aggregated value of a
! given result measured along the cross-section to the path at that particular division point. The
! path can have many vertices. Each path segment (defined by two vertices) needs to be given a node
! that defines the segment's plane, on which all the cross-sections of that segment lie. Each
! "cross-section" is, in fact, a path itself, and it extends in width to the limits of the nodes
! currently selected.

! Arguments:
! arg1: item                -  path item (as defined in PDEF) to be aggregated along a cross-section
! arg2: comp                -  path comp (as defined in PDEF) to be aggregated along a cross-section
! arg3: aggOpt              -  cross-section aggregation option, determining how the values at a
!                              virtual cross-section are reduced to the single point where it
!                              intersects with the main path:
!                                 VAL  DESCRIPTION         KEY
!                                 [ 0] Accumulated value   CUM  (integrated along cross-section)
!                                 [ 1] Maximum value       MAX
!                                 [ 2] Minimum value       MIN
!                                 [ 3] Median value        MEDI
!                                 [ 4] Mean value          MEAN
!                                 [ 5] Variance            VAR
!                                 [ 6] Standard deviation  STDV
!                                 [ 7] Root-mean-square    RMS
!                                 [ 8] Bending moment      M
!                                 [ 9] Axial force         N
!                                 [10] Shear force         V
!                                 (see *VSCFUN for options 1 through 7)
!                                 (options 8 through 10 derive from beam theory)
! arg4: csecPrefix          -  prefix applied to the name of the many paths created along the length
!                              of the path, each representing a virtual "cross-section" (best kept
!                              to a maximum length of 3 characters)
! arg5: planeDefiningNodes  -  accepts the following options to define virtual cross-section planes:
!                                 [ 0]    Use the XY plane;
!                                 [-1]    Use the YZ plane;
!                                 [-2]    Use the XZ plane;
!                                 [INT>0] Integer value is interpreted as a single node number that
!                                         every path segment will use to define its plane;
!                                 [STR]   String that is the name of an array parameter that itself
!                                         contains numbers (either -2, -1, 0, or greater than 0),
!                                         each of each being used as described above to determine
!                                         the plane for its corresponding path segment.
! arg6: overridingPathLabel -  name of the label given to the path result generated by aggregating
!                              all virtual cross-section values. If not provided a default label is
!                              generated with the following format:
!                                 <KEY>_<ITEM><COMP>
!                                 where:
!                                  • <KEY> is a 3 letter code representing the chosen aggregation
!                                    option(first 3 letters under column KEY describing arg3)
!                                  • <ITEM> and <COMP> are arg1 and arg2, respectively.

! Local parameters:
! AR20: parType
! AR21: nodeArrLength
! AR22: pathVertexCount
! AR23: dataPointCount
! AR24: divsPerSegment
! AR25: inputNodeArrayLength
! AR26: divPointOffset
! AR27: nthCS
! AR28: basePathResultName
! AR29: cumulativeResultName
! AR30: ithPathVertex
! AR31: ithPointX
! AR32: ithPointY
! AR33: ithPointZ
! AR34: beamResultName
! AR35: errorCount
! AR36: previouslyActiveCS
! AR40: jthPathVertex
! AR41: jthPointX
! AR42: jthPointY
! AR43: jthPointZ
! AR50: nthPlaneNode
! AR52: kthPointY
! AR53: kthPointZ
! AR60: segmentLength
! AR61: projectedDeltaX
! AR62: projectedDeltaY
! AR63: projectedDistance
! AR64: perpendicularDistance
! AR65: pathXMax
! AR66: pathXMin
! AR67: nodalDeltaX
! AR68: nodalYMax
! AR69: nodalYMin
! AR70: mthVirtualSection
! AR71: mthPathName
! AR72: cumulativeSectCount
! AR73: mthXAlongSegment
! AR77: selectedBeamOption
! AR78: pathLength
! AR79: stressOffset
! AR80: cumValsCount
! AR81: aggCrossSectionValue
! AR82: selectedVscfunOption
! AR83: virtualCsecPathLabel
! AR84: virtualCsecBackupFname
! AR85: existingLabelCount
! AR86: nthLabelIndex
! AR87: nthLabelValue
! AR89: previousLastValue
! AR90: pathLabel

! Output parameters:
! SCANPATH_ARR_allPathNames
! SCANPATH_ARR_allPathLabels
! SCANPATH_VAR_pathLabel
! SCANPATH_ARR_aggCsecValues

! Global parameters (erased at the end of this subroutine):
! SCANPATH_VAR_xyRotation
! SCANPATH_VAR_xzRotation
! SCANPATH_VAR_mthGlobalX1
! SCANPATH_VAR_mthGlobalY1
! SCANPATH_VAR_mthGlobalZ1
! SCANPATH_VAR_mthGlobalX2
! SCANPATH_VAR_mthGlobalY2
! SCANPATH_VAR_mthGlobalZ2
! SCANPATH_ARR_check
! SCANPATH_ARR_vscfunOptions
! SCANPATH_ARR_beamOptions
! SCANPATH_ARR_planeNodes
! SCANPATH_ARR_xAtDivs
! SCANPATH_ARR_csecVals
! SCANPATH_VAR_activePathName
! SCANPATH_VAR_labelIdx


! Mute warnings
/uis,msgpop,3

! Store active CS
csbackup
AR36=CSBackup_

! For the active path:
! Get path name
*del,SCANPATH_VAR_activePathName
actvpath,'SCANPATH_VAR_activePathName'
*get,AR20,parm,SCANPATH_VAR_activePathName,type
*if,AR20,eq,-1,then
    *msg,warn
SCANPATH error: there are no active paths.%/&
Create and activate a path to be used as basis for this command.%/&
SCANPATH command is ignored.
    *return,-1
*endif
! Get the number of vertices
*get,AR22,path,,node
! Retro-calculate the number of divisions per path segment
*get,AR23,path,,nval
AR24=1+(AR23-1)/(AR22-1)
! Validate nodes defining virtual cross-section plane at each path segment
AR21=AR22-1
*del,SCANPATH_ARR_planeNodes
*dim,SCANPATH_ARR_planeNodes,,AR21
*get,AR20,parm,arg5,type
*if,AR20,eq,0,then
    ! When a single number is passed:
    ! Exit with error if option is invalid
    *if,arg5,lt,-2,then
        *msg,warn,arg5
SCANPATH error: invalid 'planeDefiningNodes' option passed: arg5=%I.%/&
SCANPATH command is ignored.
        *return,-1
    *endif
    ! Use as node/plane number for all path segments
    *vfill,SCANPATH_ARR_planeNodes,ramp,arg5,0
*elseif,AR20,eq,3,then
    ! When a string is passed:
    *get,AR20,parm,%arg5%,type
    *if,AR20,eq,1,then
        ! When string is the name of an array parameter:
        *get,AR25,parm,%arg5%,dim,x
        *if,AR25,ne,AR21,then
            ! Exit with error if array has wrong size
            *msg,warn,AR25,AR21
SCANPATH error: given node array has length %I, but %I nodes are required for the active path.%/&
SCANPATH command is ignored.
            *return,-1
        *else
            ! Exit with error if array contains invalid number
            *del,SCANPATH_ARR_check
            *voper,SCANPATH_ARR_check,%arg5%,lt,-2
            *vscfun,AR35,sum,SCANPATH_ARR_check
            *if,AR35,gt,0,then
                *msg,warn,AR35
SCANPATH error: array of 'planeDefiningNodes' contained %I invalid values.%/&
SCANPATH command is ignored.
                *return,-1
            *endif
            ! Use node numbers stored in the array
            *vfun,SCANPATH_ARR_planeNodes,copy,%arg5%
        *endif
    *else
        ! Exit with error when string is not the name of an array parameter
        *msg,warn,
SCANPATH error: string passed for 'planeDefiningNodes' (arg5) does is not the name of an array parameter.%/&
SCANPATH command is ignored.
        *return,-1
    *endif
*else
    ! Exit with error when parameter is neither integer nor string
    *msg,warn,
SCANPATH error: invalid parameter for planeDefiningNodes.%/&
Argument must be either a node number or the name of an array containing node numbers.%/&
SCANPATH command is ignored.
    *return,-1
*endif

! Path aggregation option & path names
*del,SCANPATH_ARR_vscfunOptions
*dim,SCANPATH_ARR_vscfunOptions,char,7
SCANPATH_ARR_vscfunOptions(1)='max', 'min', 'medi', 'mean', 'vari', 'stdv', 'rms'

*del,SCANPATH_ARR_beamOptions
*dim,SCANPATH_ARR_beamOptions,char,3
SCANPATH_ARR_beamOptions(1)='m', 'n', 'v'

! Label assigned to directly extracted path result
AR28=strcat(arg1,arg2)
! Label assigned to calculated path result
*if,arg3,eq,0,then
    ! Cumulative
    AR29=strcat('CUM_',AR28)
*elseif,arg3,ge,1,and,arg3,le,7,then
    ! VSCFUN option
    AR82=SCANPATH_ARR_vscfunOptions(arg3)
*elseif,arg3,ge,8,and,arg3,le,10,then
    ! Beam option
    AR77=SCANPATH_ARR_beamOptions(arg3-7)
    AR34=strcat('BEAM_',upcase(AR77))
*endif

! Define main path's label
*get,AR20,parm,arg6,type
*if,AR20,eq,3,then
    ! Use overriding label for the path's aggregated values
    AR90=strsub(upcase(arg6),1,8)
*else
    ! Use default label
    *if,arg3,eq,0,then
        ! Accumulated
        AR90=AR29
    *elseif,arg3,le,7,then
        ! VSCFUN option
        AR90=strcat(strcat(strsub(upcase(AR82),1,3),'_'),AR28)
    *elseif,arg3,le,10,then
        ! Beam option
        AR90=strcat(strcat(strsub(upcase(AR77),1,3),'_'),AR28)
    *else
        *msg,warn,arg3
SCANPATH warning: invalid aggregation option (arg3=%I).%/&
SCANPATH command is ignored.
        *return,-1
    *endif
*endif

! Get number of data set to which aggregated cross-sectional data will be written
pthlabelidx,'SCANPATH_VAR_labelIdx',AR90
*if,SCANPATH_VAR_labelIdx,eq,0,then
    pthfreeidx,'SCANPATH_VAR_labelIdx',1
    *if,SCANPATH_VAR_labelIdx,eq,0,then
        *msg,warn
SCANPATH error: path does not have space for additional labels.%/&
SCANPATH command is ignored.
        *return,-1
    *endif
*endif

! Backup current paths
SCANPATH_VAR_backupFname='SCANPATH_pathBackup'
pasave,all,SCANPATH_VAR_backupFname,pth

! Initialize loop parameters: local CS number, path division point offset, virtual cross-section count
*get,AR27,cdsy,,num,max
AR27=(AR27>10)
AR26=0
AR72=0
*del,SCANPATH_ARR_aggCsecValues
*del,SCANPATH_ARR_allPathNames
*del,SCANPATH_ARR_allPathLabels
*dim,SCANPATH_ARR_aggCsecValues,,AR23
*dim,SCANPATH_ARR_allPathNames,char,AR23
*dim,SCANPATH_ARR_allPathLabels,char,AR23

! Calculate aggregated values at each division point for each path segment
*do,AR30,1,AR22-1,1
    ! Activate path
    paresu,all,SCANPATH_VAR_backupFname,pth
    path,%SCANPATH_VAR_activePathName%

    ! Coordinates of the vertices of the path's current segment
    *get,AR31,path,,point,AR30,x
    *get,AR32,path,,point,AR30,y
    *get,AR33,path,,point,AR30,z

    AR40=AR30+1
    *get,AR41,path,,point,AR40,x
    *get,AR42,path,,point,AR40,y
    *get,AR43,path,,point,AR40,z

    AR60=sqrt((AR41-AR31)**2+(AR42-AR32)**2+(AR43-AR33)**2)

    ! Start new set of paths
    padele,all

    ! Create local coordinate system aligned with the path's segment
    AR61=AR41-AR31
    AR62=AR42-AR32
    posang,'SCANPATH_VAR_xyRotation',AR61,AR62
    AR63=sqrt(AR61**2+AR62**2)
    AR64=AR43-AR33
    posang,'SCANPATH_VAR_xzRotation',AR63,AR64
    AR27=AR27+1
    local,AR27,cart,AR31,AR32,AR33,SCANPATH_VAR_xyRotation,,-SCANPATH_VAR_xzRotation
    csys,AR36

    AR50=SCANPATH_ARR_planeNodes(AR30)

    ! Align XY plane of local coordinate system with cross-sectional plane
    csys,AR27
        *if,AR50,eq,0,then
            ! Global XY plane
            clocal,AR27,cart,,,,0,0,0
        *elseif,AR50,eq,-1,then
            ! Global YZ plane
            clocal,AR27,cart,,,,0,0,90
        *elseif,AR50,eq,-2,then
            ! Global XZ plane
            clocal,AR27,cart,,,,0,90,0
        *elseif,AR50,gt,0,then
            ! Set plane by node number
            AR53=nz(AR50)
            *if,AR53,ne,0,then
                AR52=ny(AR50)
                posang,'SCANPATH_VAR_yzRotation',AR52,AR53
                clocal,AR27,cart,,,,,SCANPATH_VAR_yzRotation
            *endif
        *endif
    csys,AR36

    ! Calculate nodal coordinate bounding box along the path's segment in the local XY plane
    csys,AR27
        AR65=AR60
        AR66=0
        AR67=(AR65-AR66)/(AR24-1)
        *get,AR68,node,,mxloc,y
        *get,AR69,node,,mnloc,y
    csys,AR36

    ! Calculate X coordinate in local CS for each division point along the path's segment
    *del,SCANPATH_ARR_xAtDivs
    *dim,SCANPATH_ARR_xAtDivs,,AR24
    *vfill,SCANPATH_ARR_xAtDivs(1),ramp,AR66,AR67

    ! For each division in the path's segment:
    *do,AR70,1,AR24,1
        ! Set virtual cross-section's path name
        AR72=AR72+1
        AR71='%arg4%_%AR72%'

        ! Calculate virtual cross-section's coordinates in global CS
        AR73=SCANPATH_ARR_xAtDivs(AR70)
        loc2glo,AR73,AR69,0,AR27,'SCANPATH_VAR_mthGlobalX1','SCANPATH_VAR_mthGlobalY1','SCANPATH_VAR_mthGlobalZ1'
        loc2glo,AR73,AR68,0,AR27,'SCANPATH_VAR_mthGlobalX2','SCANPATH_VAR_mthGlobalY2','SCANPATH_VAR_mthGlobalZ2'

        ! Create virtual cross-section's path
        path,%AR71%,2
        ppath,1,,SCANPATH_VAR_mthGlobalX1,SCANPATH_VAR_mthGlobalY1,SCANPATH_VAR_mthGlobalZ1
        ppath,2,,SCANPATH_VAR_mthGlobalX2,SCANPATH_VAR_mthGlobalY2,SCANPATH_VAR_mthGlobalZ2
        pdef,%AR28%,arg1,arg2

        ! Use zero if PDEF failed
        *if,_STATUS,eq,2,or,_STATUS,eq,3,then
            AR81=0
        *else
            ! Extract aggregated virtual cross-section value
            *if,arg3,eq,0,then
                ! Accumulated
                pcalc,intg,%AR29%,%AR28%,'S'
                pth2arr,AR29,'SCANPATH_ARR_csecVals'
                *get,AR80,parm,SCANPATH_ARR_csecVals,dim,x
                AR81=SCANPATH_ARR_csecVals(AR80)
            *elseif,arg3,le,7,then
                ! VSCFUN option
                pth2arr,AR28,'SCANPATH_ARR_csecVals'
                *vscfun,AR81,%AR82%,SCANPATH_ARR_csecVals
            *elseif,arg3,le,10,then
                ! Beam option (axial or shear forces)
                pcalc,intg,%AR34%,%AR28%,'S'
                pth2arr,AR34,'SCANPATH_ARR_csecVals'
                *get,AR80,parm,SCANPATH_ARR_csecVals,dim,x
                AR81=SCANPATH_ARR_csecVals(AR80)

                *if,arg3,eq,8,then
                    ! Bending moment special case
                    *get,AR78,path,,last,'S'
                    AR79=AR81/AR78
                    pcalc,add,'%AR28%_B',%AR28%,,,,-AR79
                    pcalc,mult,'%AR28%_DM','%AR28%_B','S'
                    pcalc,intg,%AR34%,'%AR28%_DM','S'
                    pth2arr,AR34,'SCANPATH_ARR_csecVals'
                    *get,AR80,parm,SCANPATH_ARR_csecVals,dim,x
                    AR81=SCANPATH_ARR_csecVals(AR80)
                *endif
            *endif
        *endif



        ! Average first segment's value with last value from previous segment
        *if,AR30,gt,1,and,AR70,eq,AR24,then
            AR81=(AR81+AR89)/2
        *endif

        ! Store aggregated value
        SCANPATH_ARR_aggCsecValues(AR70+AR26)=AR81

        ! Store virtual cross-section path info
        *if,arg3,eq,0,then
            ! Accumulated
            AR83=AR29
        *elseif,arg3,le,7,then
            ! VSCFUN option
            AR83=AR28
        *elseif,arg3,le,10,then
            ! Beam option
            AR83=AR34
        *endif
        SCANPATH_ARR_allPathNames(AR70+AR26)=AR71
        SCANPATH_ARR_allPathLabels(AR70+AR26)=AR83
    *enddo

    ! Store this segment's last value
    AR89=AR81

    ! Save segment's paths to external path file, revert to backed up paths
    AR84='SCANPATH_%SCANPATH_VAR_activePathName%_S%AR30%_%AR90%'
    pasave,all,%AR84%,pth
    paresu,all,SCANPATH_VAR_backupFname,pth

    ! Increment overall path division point offset
    AR26=AR26+AR24-1
*enddo

! Reactivate original path
paresu,all,SCANPATH_VAR_backupFname,pth
path,%SCANPATH_VAR_activePathName%
/delete,SCANPATH_VAR_backupFname,pth

! Transfer aggregated virtual cross-section data to path
arr2pth,'SCANPATH_ARR_aggCsecValues',AR90,SCANPATH_VAR_labelIdx
*del,SCANPATH_VAR_pathLabel
SCANPATH_VAR_pathLabel=AR90

! Restore previously active CS
csrestore

! Clear parameters
*del,SCANPATH_VAR_xyRotation
*del,SCANPATH_VAR_xzRotation
*del,SCANPATH_VAR_mthGlobalX1
*del,SCANPATH_VAR_mthGlobalY1
*del,SCANPATH_VAR_mthGlobalZ1
*del,SCANPATH_VAR_mthGlobalX2
*del,SCANPATH_VAR_mthGlobalY2
*del,SCANPATH_VAR_mthGlobalZ2
*del,SCANPATH_ARR_vscfunOptions
*del,SCANPATH_ARR_beamOptions
*del,SCANPATH_ARR_planeNodes
*del,SCANPATH_ARR_xAtDivs
*del,SCANPATH_ARR_csecVals
*del,SCANPATH_VAR_activePathName
*del,SCANPATH_ARR_check
*del,SCANPATH_VAR_labelIdx

! Restore warnings
!/uis,msgpop,2








